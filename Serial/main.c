#include <math.h>
#include <stdio.h>
#include <stdlib.h>

#define T 3
#define DIMX 10000
#define DIMY 10000
#define RAINDROP 120.00
#define MAX_ITER 100

/**********************************************************/
// Method to initialize u, alpha.
/**********************************************************/
void initialize(double *u[T], double *alpha){
/**********************************************************/
//LOCAL VARIABLES
/**********************************************************/
    const int h=1;
    const int l=1;
    const double c=0.5;
/**********************************************************/
//METHOD BODY
/**********************************************************/
    *alpha = pow(((c*l)/h), 2);

    for(int i=0; i<T; i+=1){
        u[i]=(double *)malloc(sizeof(double)*DIMX*DIMY);
    }//end-for

    for(int k=0; k<T; k+=1){
        for(int i=0; i<DIMX*DIMY; i+=1){
            u[k][i] = 0;
        }//end-for
    }//end-for
/**********************************************************/
}

/**********************************************************/
// Method to shift matrices
/**********************************************************/
void matrixShifting(double u[], double v[]){
/**********************************************************/
//METHOD BODY
/**********************************************************/
    for(int i = 0; i < DIMX*DIMY; i+=1){
        u[i] = v[i];
    }//end-for
/**********************************************************/
}

/**********************************************************/
// Method used to remove energy from the system
/**********************************************************/
void absorbingEnergy(double u[]){
/**********************************************************/
//LOCAL VARIABLES
/**********************************************************/
    int y=0;
/**********************************************************/
//METHOD BODY
/**********************************************************/
    for(int i=0; i<DIMX*DIMY; i+=1){
        //matrix notation
        const int x = (i) / (DIMY);
        y = ((i)%(DIMY));

        if (x!=0 && y!=0 && x!=DIMX-1 && y!=DIMY-1) {
            u[i] *= 0.995;
        }//end-if
    }//end-for
/**********************************************************/
}

/**********************************************************/
// Method used to visualize the matrices
/**********************************************************/
void printMatrix(double u[]){
/**********************************************************/
//METHOD BODY
/**********************************************************/
    for(int i = 0; i < DIMX; i+=1){
        for(int j = 0; j < DIMY; j+=1){
            printf("%3.1f ", u[(i*DIMY) + j]);
        }//end-for
        printf("\n");
    }//end-for
    printf("\n\n\n");
/**********************************************************/
}

/**********************************************************/
// Method implementing the actual 2D wave equation
/**********************************************************/
void update(double u0[], const double u1[], const double u2[], const double alpha){
/**********************************************************/
//LOCAL VARIABLES
/**********************************************************/
    int y=0;
/**********************************************************/
//METHOD BODY
/**********************************************************/
    for(int i=0; i<DIMX*DIMY; i+=1){
        //matrix notation
        const int x = (i) / (DIMY);
        y = ((i)%(DIMY));

        if (x!=0 && y!=0 && x!=DIMX-1 && y!=DIMY-1){
            u0[i]= alpha*(u1[(x-1)*DIMY + y] + u1[(x+1)*DIMY + y] + u1[(x)*DIMY +(y-1)] + u1[(x)*DIMY + (y+1)] -4*u1[x*DIMY+y]);
            u0[i]+= 2*u1[x*DIMY+y] - u2[i];
        }//end-if
    }//end-for
/**********************************************************/
}

/**********************************************************/
// Method to virtually place a raindrop
/**********************************************************/
void perturbate(double u[]){
/**********************************************************/
//METHOD BODY
/**********************************************************/
    const double num=rand() % 1;
    if(num<0.02){
        int y=0;
        int x=0;
        x=rand() % ((DIMX-5) - 5 + 1) + 5;
        y=rand() % ((DIMY-5) - 5 + 1) + 5;

        for(int i = (x-2); i < (x+2); i++){
            for(int j = (y-2); j < (y+2); j++){
                u[(i * DIMY) + j] = RAINDROP;
            }//end-for
        }//end-for
    }//end-if
/**********************************************************/
}

/**********************************************************/
// Method to save a matrix into a file
/**********************************************************/
void createFile(FILE *fp, double u[], char filename[]){
/**********************************************************/
//METHOD BODY
/**********************************************************/
    fp=fopen(filename,"a+");
    for(int i=0; i<DIMX; i+=1) {
        for(int j=0; j<DIMY; j+=1) {
            fprintf(fp,"%f ", u[(i * DIMY) + j]);
        }
        fprintf(fp,"\n");
    }
    fclose(fp);
/**********************************************************/
}

/**********************************************************/
int main(int argc, char **argv){
/**********************************************************/
//LOCAL VARIABLES
/**********************************************************/
    double *u[T];  //3 bc time has 3 parameters (u0, u1, u2)
    double alpha;
    // FILE *fp0;
    // FILE *fp1;
    // FILE *fp2;
/**********************************************************/
//METHOD BODY
/**********************************************************/
    srand(1);
    initialize(u, &alpha);

    int count=0;
    while(count<MAX_ITER){
        perturbate(u[0]);

        //u[2]=u[1]
        matrixShifting(u[2], u[1]);

        //u[1]=u[0]
        matrixShifting(u[1], u[0]);

        update(u[0], u[1], u[2], alpha);

        absorbingEnergy(u[0]);

        count+=1;
    }//end-while

    for(int i=0; i<T; i+=1){
        free(u[i]);
    }//end-for

    return 0;
/**********************************************************/
}